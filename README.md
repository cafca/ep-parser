# EP Amendments Parser

A command-line tool that extracts structured data from European Parliament committee amendment PDFs into machine-readable JSON. Written for the JURI committee amendment format but applicable to any EP committee document sharing the same two-column layout.

## Background

EP amendment PDFs present text in a two-column table: the left column contains the original legislative text, and the right column contains the proposed replacement. Each amendment block opens with a bold `Amendment N` header, lists one or more authors, identifies the affected section, and closes with a language marker such as `Or. en`. This tool parses that structure via coordinate-based span analysis rather than relying on PDF table extraction, which is unreliable for this document class.

## Requirements

Python 3.9 or later. The only runtime dependency is PyMuPDF:

```
pip install pymupdf
```

## Usage

```
python parse_amendments.py <input.pdf> [-o output.json]
```

Progress is written to stderr; the JSON output goes to the file specified by `-o` (default: `amendments.json`).

## Output format

Each amendment is represented as a JSON object:

```json
{
  "id": "Amendment 42",
  "authors": "Jane Smith; on behalf of the Verts/ALE Group",
  "section": "Motion for a resolution / Recital A",
  "content": "whereas the existing framework...",
  "amendment": "whereas a revised framework...",
  "warnings": []
}
```

`content` holds the original text from the left column; `amendment` holds the proposed text from the right column. When an amendment proposes a deletion the right column typically contains only the word `deleted` and `content` is empty where the original is new text.

The `warnings` array is empty for cleanly parsed amendments. Non-empty values indicate reliability concerns:

| Warning | Meaning |
|---|---|
| `non_sequential_id` | Amendment number is not sequential — possible missed block |
| `missing_author` | No author line detected between header and section label |
| `both_columns_empty` | Both columns produced no text |
| `suspiciously_short_column` | A column is non-empty but under 3 characters |
| `no_language_marker` | Amendment ended without an `Or. xx` marker |
| `ambiguous_column_split` | One or more spans fell in the boundary zone (x 220–300 pt) |
| `footer_text_leaked` | Document code pattern found in extracted text |

## How it works

Parsing proceeds in four phases.

**Phase 1 — Span extraction.** PyMuPDF's `get_text("dict")` yields every typographic span with its bounding-box origin, font size, and bold flag. Spans below y = 760 pt (the true footer row sits at y ≈ 771) and spans with font size ≥ 20 pt (the large `EN` watermark) are discarded.

**Phase 2 — Line assembly.** Spans on the same page whose y-coordinates are within 2 pt of each other are merged into a single logical line, ordered left to right by x-coordinate.

**Phase 3 — State machine.** A linear pass over the assembled lines drives a state machine through the states `PREAMBLE → AUTHORS → TABLE_BODY`. A bold line matching `Amendment \d+` at font size ≥ 11 pt starts a new amendment. Subsequent bold lines are classified as author names or section identifiers based on whether they contain known structural keywords (`Motion for a resolution`, `Recital`, `Article`, etc.). The non-bold column-header row (`Motion for a resolution` near x = 120 pt) signals the transition to `TABLE_BODY`. Within the table body each span is assigned to `content` (x < 244 pt) or `amendment` (x ≥ 244 pt). An `Or. xx` language marker closes the block.

**Phase 4 — Output.** Accumulated text is joined, heuristic checks are applied, and the result is serialised as a JSON array.

## Coordinate reference (A4, ~595 × 842 pt)

| Zone | x range |
|---|---|
| Left column (original text) | 71 – 244 pt |
| Column gap | 244 – 315 pt |
| Right column (amendment text) | 315 – 530 pt |
| Footer row | y ≈ 771 pt |

## Limitations

The parser is tuned to the coordinate layout of JURI committee documents generated by the EP's document system. Documents from other committees or produced by different software may use different x-offsets and will require adjusting the constants at the top of `parse_amendments.py`. Multi-page amendments where the amendment header falls at the very bottom of a page (forcing an author-line page break) are handled correctly; however, other unusual page-break positions may occasionally cause a section identifier to be misclassified as an author or vice versa.

## License

MIT
